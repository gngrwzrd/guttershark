package gs.display.flv{	import gs.events.FLVEvent;	import gs.managers.AssetManager;	import gs.util.MathUtils;	import flash.events.EventDispatcher;	import flash.events.NetStatusEvent;	import flash.events.TimerEvent;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.utils.Timer;	import flash.utils.setTimeout;	/**	 * Dispatched when the flv starts playing. The event	 * manager can handle this event, as "Start".	 * 	 * @eventType gs.support.events.FLVEvent	 */	[Event("start", type="gs.support.events.FLVEvent")]		/**	 * Dispatched when the flv stops playing. The event	 * manager can handle this event, as "Stop".	 * 	 * @eventType gs.support.events.FLVEvent	 */	[Event("stop", type="gs.support.events.FLVEvent")]		/**	 * Dispatched for progress of the flv. The event	 * manager can handle this event, as "Progress".	 * 	 * @eventType gs.support.events.FLVEvent	 */	[Event("progress", type="gs.support.events.FLVEvent")]		/**	 * Dispatched when meta data is received for the current flv. The event	 * manager can handle this event, as "Meta".	 * 	 * @eventType gs.support.events.FLVEvent	 */	[Event("metaData", type="gs.support.events.FLVEvent")]		/**	 * Dispatched when the buffer is empty. The event	 * manager can handle this event, as "BufferEmpty".	 * When this is dispatched, you should pause the video,	 * and wait for the buffer full event.	 * 	 * @eventType gs.support.events.FLVEvent	 */	[Event("bufferEmpty", type="gs.support.events.FLVEvent")]		/**	 * Dispatched when the buffer is full. The event	 * manager can handle this event, as "BufferFull".	 * When this is dispatched, you can begin playing	 * the video again - call play or resume.	 * 	 * @eventType gs.support.events.FLVEvent	 */	[Event("bufferFull", type="gs.support.events.FLVEvent")]		/**	 * Dispatched when the buffer was flushed. The event	 * manager can handle this event, as "BufferFlush".	 * 	 * @eventType gs.support.events.FLVEvent	 */	[Event("bufferFlush", type="gs.support.events.FLVEvent")]		/**	 * Dispatched when an invalid seek time was attempted. The event	 * manager can handle this event, as "SeekInvalidTime".	 * 	 * @eventType gs.support.events.FLVEvent	 */	[Event("seekInvalidTime", type="gs.support.events.FLVEvent")]		/**	 * Dispatched when a seek occurs. The event	 * manager can handle this event, as "SeekNotify".	 * 	 * @eventType gs.support.events.FLVEvent	 */	[Event("seekNotify", type="gs.support.events.FLVEvent")]		/**	 * Dispatched when a stream was not found. The event	 * manager can handle this event, as "StreamNotFound".	 * 	 * @eventType gs.support.events.FLVEvent	 */	[Event("streamNotFound", type="gs.support.events.FLVEvent")]		/**	 * Dispatched when a cue point is reached. The event	 * manager can handle this event, as "CuePoint".	 * 	 * @eventType gs.support.events.FLVEvent	 */	[Event("cuePoint", type="gs.support.events.FLVEvent")]		/**	 * The FLV class loads and plays an FLV.	 * 	 * <p>It's integrated with the AssetManager so if you preload	 * an flv, f4v, or mp4 the net stream will be availale in the	 * asset manager, and an FLV instance would use the cached	 * net stream (pulling it from the asset manager).</p>	 * 	 * <p>You have to add the <code>video</code> property to the display list.</p>	 * 	 * <p><b>Examples</b> are in the guttershark repository.</p>	 */	public class FLV extends EventDispatcher	{				/**		 * Whether or not to trace out status events		 * from the net stream.		 */		public var traceStatuses:Boolean;				/**		 * @private		 * The net stream object.		 */		protected var stream:NetStream;				/**		 * @private		 * The net connection for the flv.		 */		protected var nc:NetConnection;				/**		 * @private		 * The video object.		 */		protected var display:Video;				/**		 * @private		 * The url currently playing.		 */		protected var url:String;				/**		 * @private		 * Pased flag.		 */		protected var paused:Boolean;				/**		 * @private		 * Started flag.		 */		protected var started:Boolean;				/**		 * @private		 * The duration of the current flv.		 */		public var duration:Number;				/**		 * Meta data about the flv. This is the meta data object		 * that comes from the net stream meta data event.		 */		private var _metadata:Object;				/**		 * XMP data stored in the flv. This is the XMP data object		 * that comes from the net stream xmp data event.		 */		private var _xmpdata:Object;				/**		 * @private		 * The last seekable time.		 */		protected var lastSeekableTime:Number;		/**		 * The amount of pixels to use when calculating		 * how many pixels have played and how many		 * pixels for buffer are full.		 */		public var pixelsToFill:int;		/**		 * A timer that polls the net stream for status.		 */		private var checkTimer:Timer;				/**		 * Flag for buffering.		 */		private var buffering:Boolean;				/**		 * Flag for the buffer full event - which doesn't		 * always dispatch when the buffer is indeed full.		 */		private var dispatchedBufferFull:Boolean;				/**		 * A count for the dispatchedBufferFull flag - which		 * determines when an event is forcefully dispatched.		 */		private var checkBufferCount:Number;		/**		 * Constructor for FLV instances.		 * 		 * @param width The width of the video object.		 * @param height The height of the video object.		 * @param smoothing Whether or not smoothing is applied.		 * @param updateInterval The millisecond interval to poll for progress and buffer.		 * @param pixelsToFill The amount of pixels to fill for a progress status bar.		 */		public function FLV(pixelsToFill:int=100,updateIntervalMS:int=400)		{			super();			this.pixelsToFill=pixelsToFill;			duration=1000000000;			checkTimer=new Timer(updateIntervalMS);			checkTimer.addEventListener(TimerEvent.TIMER,ontick,false,0,true);			display=new Video();			checkBufferCount=0;		}		/**		 * Loads the video, and optionally shows the first frame.		 * 		 * @param url The url of the FLV to load.		 * @param width The width of the video.		 * @param height The height of the video.		 * @param buffer Seconds of buffer to maintain.		 * @param autoPlay Whether or not to auto play the video.		 * @param showFirstFrame Whether or not to show the first frame of the flv if auto play is false.		 */		public function load(url:String,width:int=320,height:int=240,buffer:uint=4,autoPlay:Boolean=false,showFirstFrame:Boolean=true):void		{			if(this.url&&this.url==url)return;			if(this.url&&this.url!=url)dispatchEvent(new FLVEvent(FLVEvent.URL_CHANGE,url));			this.url=url;			started=false;			paused=false;			if(!nc)			{				nc=new NetConnection();				nc.connect(null);			}			if(!display) display=new Video(width,height);			else if(width != display.width && height != display.height)			{				display.width=width;				display.height=height;			}			display.smoothing=true;			display.clear();			if(stream)			{				stream.pause();				stream.removeEventListener(NetStatusEvent.NET_STATUS,onNSStatus);			}			if(AssetManager.isAvailable(url)) stream=AssetManager.getNetStream(url);			else			{				stream=new NetStream(nc);				AssetManager.addAsset(url,stream);			}			stream.addEventListener(NetStatusEvent.NET_STATUS,onNSStatus,false,0,true);			stream.client=this;			stream.bufferTime=buffer;			display.clear();			display.attachNetStream(stream);			buffering=true;			if(autoPlay)play();			if(!autoPlay&&showFirstFrame)			{				play();				setTimeout(seek,500,0);				setTimeout(pause,300);			}			checkTimer.start();		}				/**		 * Safety check for a url, that makes sure play, pause, resume can be		 * called without error.		 */		private function checkURL():void		{			if(!url) throw new Error("An flv has not been loaded, you must call load() before anything can be done.");		}				/**		 * The update interval for progress updates.		 */		public function set updateInterval(val:Number):void		{			if(checkTimer.delay==val)return;			if(checkTimer.running)			{				checkTimer.stop();				checkTimer.removeEventListener(TimerEvent.TIMER,ontick);				checkTimer=new Timer(val);				checkTimer.addEventListener(TimerEvent.TIMER,ontick);				checkTimer.start();			}			else			{				checkTimer.removeEventListener(TimerEvent.TIMER,ontick);				checkTimer.addEventListener(TimerEvent.TIMER,ontick);			}		}				/**		 * The update interval for progress.		 */		public function get updateInterval():Number		{			return checkTimer.delay;		}				/**		 * Start the timer, it it's not already running.		 */		private function startTimer():void		{			if(!checkTimer.running) checkTimer.start();		}				/**		 * Stop the timer.		 */		private function stopTimer():void		{			if(!checkTimer)return;			checkTimer.stop();		}				/**		 * Video width.		 */		public function set width(w:Number):void		{			display.width=w;		}				/**		 * Video width.		 */		public function get width():Number		{			return display.width;		}				/**		 * Video height.		 */		public function set height(h:Number):void		{			display.height=h;		}				/**		 * Video height.		 */		public function get height():Number		{			return display.height;		}				/**		 * Set the smoothing property on the video.		 */		public function set smoothing(v:Boolean):void		{			display.smoothing=v;		}				/**		 * 		 */		public function set metadata(val:Object):void		{			if(!val) return;			_metadata=val;			duration=_metadata.duration;			lastSeekableTime=_metadata.lastkeyframetimestamp;			dispatchEvent(new FLVEvent(FLVEvent.METADATA,url,0,0,0,0,0,null,metadata));		}				public function get metadata():Object		{			return _metadata;		}				public function set xmpdata(val:Object):void		{			if(!val) return;			_xmpdata=xmpdata;			//var duration:Number = xmpdata.duration;			//var lastSeekableTime:Number = xmpdata.lastkeyframetimestamp;		   	var cuepoints:Array=[];             var cuepoint:Object;             var strFrameRate:String;			var nTracksFrameRate:Number;             var strTracks:String="";			var onXMPXML:XML=new XML(xmpdata.data);			var xmpDM:Namespace = new Namespace("http://ns.adobe.com/xmp/1.0/DynamicMedia/"); 			var rdf:Namespace = new Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#"); 			for each (var it:XML in onXMPXML..xmpDM::Tracks)			{				//var strTrackName:String = it.rdf::Bag.rdf::li.rdf::Description.@xmpDM::trackName;				var strFrameRateXML:String = it.rdf::Bag.rdf::li.rdf::Description.@xmpDM::frameRate; 				strFrameRate = strFrameRateXML.substr(1,strFrameRateXML.length); 				nTracksFrameRate = Number(strFrameRate);				strTracks += it;             }			var onXMPTracksXML:XML=new XML(strTracks);            //traverse Sequence 			for each(var item:XML in onXMPTracksXML..xmpDM::markers) 			{ 				//traverse each list-item for cuepoints				var li:XML;				for each(li in item.rdf::Seq.rdf::li)				{										var thisItem:XMLList;					//if it has children, that means the cuepoint is structured differently because it has parameters defined					if(li.children().length()>0) thisItem = li.rdf::Description;					else thisItem = XMLList(li);					var marker:XML;					for each(marker in thisItem)					{						cuepoint={}; 						cuepoint.time = Number(marker.@xmpDM::startTime.toXMLString()/nTracksFrameRate);						cuepoint.name = marker.@xmpDM::name.toXMLString();						cuepoint.type = marker.@xmpDM::cuePointType.toXMLString();						cuepoint.parameters={};						//traverse each parameter for this cuepoint						for each(var param:XML in marker..rdf::Seq.rdf::li)						{							cuepoint.parameters[param.@xmpDM::key.toXMLString()]=param.@xmpDM::value.toXMLString();						}						cuepoints.push(cuepoint);					}				}            }			dispatchEvent(new FLVEvent(FLVEvent.XMP_DATA,url,0,0,0,0,0,cuepoints,null,xmpdata));		}				public function get xmpdata():Object		{			return _xmpdata;		}				/**		 * Play the flv.		 */		public function play():void		{			checkURL();			startTimer();			display.clear();			if(started||stream.bytesLoaded>0)			{				stream.seek(0);				stream.resume();			}			else stream.play(url);			dispatchEvent(new FLVEvent(FLVEvent.START));			started=true;			paused=false;		}				/**		 * Seeks to 0 and plays.		 */		public function playFromBeginning():void		{			seek(0);			play();		}				/**		 * Stop the flv.		 */		public function stop():void		{			checkURL();			if(!stream)return;			stream.pause();			dispatchEvent(new FLVEvent(FLVEvent.STOP));			started=false;			paused=false;		}				/**		 * Stop the flv, and seeks to the specified position.		 * 		 * @param position The seek position.		 */		public function seekToAndStop(position:Number=0):void		{			stop();			seek(position);		}				/**		 * Pause the flv.		 */		public function pause():void		{			checkURL();			if(!paused && started)			{				paused=true;				stream.pause();				dispatchEvent(new FLVEvent(FLVEvent.STOP));			}		}		/**		 * Resume the flv playback.		 */		public function resume():void		{			checkURL();			if(paused && started)			{				startTimer();				paused=false;				stream.resume();				dispatchEvent(new FLVEvent(FLVEvent.START));			}		}		/**		 * Pauses or resumes the flv.		 */		public function pauseResume():void		{			if(paused) resume();			else pause();		}				/**		 * Fast-forward playback.		 * 		 * @param step seconds to step forward.		 */		public function forward(step:Number=2):void		{			checkURL();			seek(getTime()+step);		}		/**		 * Rewind playback.		 * 		 * @param step seconds to step backwards.		 */		public function rewind(step:Number=2):void		{			checkURL();			seek(getTime()-step);		}				/**		 * Check if the FLV is paused.		 */		public function isPaused():Boolean		{			return paused;		}		/**		 * Check if the FLV is playing.		 */		public function isPlaying():Boolean 		{			return started;		}		/**		 * Check if the FLV is stopped.		 */		public function isStopped():Boolean		{			return !started;		}		/**		 * @private		 * The current time of the flv.		 */		public function getTime():Number		{			return stream.time;		}				/**		 * Get the current time.		 */		public function get currentTime():Number		{			return stream.time;		}				/**		 * Get the total time.		 */		public function get totalTime():Number		{			return duration;		}				/**		 * Seek to a playback time.		 * 		 * <p>note that unless you're using a flash media server, it will		 * only seek to the nearest key frame (i-frame) (see video docs in		 * flash help for more info).</p>		 * 		 * @param time The time in seconds to seek to.		 */		public function seek(time:Number):void		{			stream.seek(resolveTime(time));		}		/**		 * Seek to a playback percent.		 * 		 * @param percent of playback to seek to.		 */		public function seekToPercent(percent:Number):void		{			seek(duration*percent/100);		}				/**		 * Seek to a width based off of the pixelsToFill property.		 * 		 * <p>For example, if the pixels to fill was 300, you could		 * seek anywhere between 0-300.</p>		 * 		 * @param pixel The width to seek to.		 */		public function seekToPixel(pixel:int):void		{			if(pixelsToFill < 1)			{				trace("WARNING: pixelsToFill is less than 1, no seeking will occur.");				return;			}			seek(resolveTime(MathUtils.spread(pixel,pixelsToFill,duration)));		}				/**		 * The percent of the video that has played.		 */		public function get percentPlayed():Number		{			return Math.ceil(getTime()*100/duration);		}						/**		 * The percent of the video that has loaded.		 */		public function get percentLoaded():Number		{			var b:Number=Math.round(stream.bytesLoaded/stream.bytesTotal*100);			return (isNaN(b))?0:b;		}		/**		 * The percent of the total buffer that is full.		 */		public function get percentBuffered():Number		{			var total:Number=Math.min(duration,stream.bufferTime);			var b:Number=Math.min(Math.round(stream.bufferLength/total*100),100);			return (isNaN(b))?0:b;		}				/**		 * @private		 * The amount of pixels that are full. For example, you might 		 * set the pixels to fill to 300, and if only half of the buffer		 * is full, you'd get back the number 150.		 */		public function get pixelsBuffered():Number		{			return MathUtils.spread(stream.bufferLength,stream.bufferTime,pixelsToFill);		}				/**		 * The amount of pixels that are full.		 * 		 * <p>For example, you might set the pixels to fill to 300, and if the		 * movie is 50% played through, you'd get back the number 150. Which		 * correlates to 50% of 300.</p>		 */		public function get pixelsPlayed():Number		{			return MathUtils.spread(getTime(),duration,pixelsToFill);		}						/**		 * Set the video volume.		 * 		 * @param volume The volume level - 0-1.		 */		public function set volume(volume:Number):void		{			if(!stream) return;			stream.soundTransform=new SoundTransform(volume);		}				/**		 * The volume of the video player.		 */		public function get volume():Number		{			if(!stream)return 0;			return stream.soundTransform.volume;		}				/**		 * The sound transform of the stream.		 */		public function get soundTransform():SoundTransform		{			if(stream) return stream.soundTransform;			return null;		}				/**		 * Sets the sound transform on the stream.		 */		public function set soundTransform(st:SoundTransform):void		{			stream.soundTransform=st;		}		/**		 * The internal video object used to display the		 * flv.		 */		public function get video():Video		{			return display;		}		/**		 * The currently playing net stream.		 */		public function get netStream():NetStream		{			return stream;		}		/**		 * @private		 * 		 * Formats time so that it fits inside the available seek scope.		 * 		 * @param time The time from the net stream.		 */		protected function resolveTime(time:Number):Number		{			var maxTime:Number=(!isNaN(lastSeekableTime))?lastSeekableTime:duration;			return Math.max(Math.min(time,maxTime),0);		}				/**		 * Stops and closes the net stream and net connection.		 */		public function close():void		{			if(stream)			{				if(AssetManager.isAvailable(url))AssetManager.removeAsset(url);				stream.removeEventListener(NetStatusEvent.NET_STATUS,onNSStatus);				stream.close();				stream=null;			}			if(nc)			{				nc.close();				nc=null;			}		}				/**		 * Stops playback, closes the net stream, and		 * removes the net stream from the asset manager.		 */		public function dispose():void		{			stop();			stopTimer();			if(checkTimer) checkTimer.removeEventListener(TimerEvent.TIMER,ontick);			if(display)display.clear();			close();			display=null;		}				/**		 * @private		 * 		 * Progress frame loop to keep client progress up to date.		 */		protected function ontick(te:TimerEvent):void		{			if(display == null) return;			if(hasEventListener(FLVEvent.PROGRESS))dispatchEvent(new FLVEvent(FLVEvent.PROGRESS,url,percentLoaded,percentPlayed,percentBuffered,pixelsBuffered,pixelsPlayed,null,metadata,stream.bytesLoaded,stream.bytesTotal));						if(percentBuffered>=100)			{				checkBufferCount++;				if(checkBufferCount>4 && !dispatchedBufferFull)				{					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_FULL));					buffering=false;					dispatchedBufferFull=true;					checkBufferCount=0;				}			}		}				/**		 * @private		 * NetStatus handler.		 */		protected function onNSStatus(stats:NetStatusEvent):void		{			if(traceStatuses) trace("netstat: ",stats.info.code);			switch(stats.info.code)			{				case "NetStream.Buffer.Empty":					buffering=true;					dispatchedBufferFull=false;					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_EMPTY));					break;				case "NetStream.Buffer.Full":					buffering=false;					dispatchedBufferFull=true;					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_FULL));					break;				case "NetStream.Buffer.Flush":					buffering=false;					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_FLUSH));					break;				case "NetStream.Play.Start":					dispatchEvent(new FLVEvent(FLVEvent.START));					break;				case "NetStream.Play.Stop":					dispatchEvent(new FLVEvent(FLVEvent.STOP));					break;				case "NetStream.Play.StreamNotFound":					stopTimer();					dispatchEvent(new FLVEvent(FLVEvent.STREAM_NOT_FOUND,url));					break;				case "NetStream.Seek.InvalidTime":					dispatchEvent(new FLVEvent(FLVEvent.SEEK_INVALID_TIME));					break;				case "NetStream.Seek.Notify":					dispatchEvent(new FLVEvent(FLVEvent.SEEK_NOTIFY));					break;			}		}				/**		 * @private		 * XMP Data handler.		 */		public function onXMPData(xmpdat:Object):void		{			try{this.xmpdata = xmpdat;}catch(e:*){}		}				/**		 * @private		 * CuePoint handler.		 */		public function onCuePoint(infoObject:Object):void		{			if(buffering) return;			dispatchEvent(new FLVEvent(FLVEvent.CUE_POINT,url,percentLoaded,percentPlayed,percentBuffered,pixelsBuffered,pixelsPlayed,infoObject,null));		}				/**		 * @private		 * Meta data handler.		 */		public function onMetaData(metadata:Object):void		{			this.metadata=metadata;		}	}}